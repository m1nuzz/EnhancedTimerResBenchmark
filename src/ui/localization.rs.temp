//! Localization module for multilingual support
//!
//! This module provides internationalization support for all UI elements
//! in the timer resolution benchmark tool.

use crate::ui::language::Language;
pub use crate::ui::localization_key::LocalizationKey;

/// Localization system for multilingual support
pub struct Localization {
    pub language: Language,
}

impl Localization {
    /// Create a new localization instance for the specified language
    pub fn new(language: Language) -> Self {
        Self { language }
    }
    
    /// Get localized string for a given key
    pub fn get(&self, key: LocalizationKey) -> &'static str {
        match self.language {
            Language::English => key.get_english(),
            Language::Ukrainian => key.get_ukrainian(),
            Language::Russian => key.get_russian(),
            Language::Chinese => key.get_chinese(),
        }
    }
    
    /// Format working directory string based on selected language
    pub fn get_working_dir(&self, path: &str) -> String {
        match self.language {
            Language::English => format!("ğŸ“‚ Working Directory: {}", path),
            Language::Ukrainian => format!("ğŸ“‚ Ğ Ğ¾Ğ±Ğ¾Ñ‡Ğ° Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ñ–Ñ: {}", path),
            Language::Russian => format!("ğŸ“‚ Ğ Ğ°Ğ±Ğ¾Ñ‡Ğ°Ñ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ: {}", path),
            Language::Chinese => format!("ğŸ“‚ å·¥ä½œç›®å½•: {}", path),
        }
    }
    
    /// Format Windows version string based on selected language
    pub fn get_windows_version(&self, info: &str) -> String {
        match self.language {
            Language::English => format!("ğŸ–¥ï¸ Windows Version: {}", info),
            Language::Ukrainian => format!("ğŸ–¥ï¸ Ğ’ĞµÑ€ÑÑ–Ñ Windows: {}", info),
            Language::Russian => format!("ğŸ–¥ï¸ Ğ’ĞµÑ€ÑÑ–Ñ Windows: {}", info),
            Language::Chinese => format!("ğŸ–¥ï¸ Windows ç‰ˆæœ¬: {}", info),
        }
    }
    
    /// Format CPU information string based on selected language
    pub fn get_cpu(&self, cpu: &str) -> String {
        match self.language {
            Language::English => format!("ğŸ’» CPU: {}", cpu),
            Language::Ukrainian => format!("ğŸ’» ĞŸÑ€Ğ¾Ñ†ĞµÑĞ¾Ñ€: {}", cpu),
            Language::Russian => format!("ğŸ’» ĞŸÑ€Ğ¾Ñ†ĞµÑÑĞ¾Ñ€: {}", cpu),
            Language::Chinese => format!("ğŸ’» CPU: {}", cpu),
        }
    }
    
    /// Format range information based on selected language
    pub fn get_range(&self, low: f64, high: f64) -> String {
        match self.language {
            Language::English => format!("Range: [{:.4}, {:.4}] ms", low, high),
            Language::Ukrainian => format!("Ğ”Ñ–Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½: [{:.4}, {:.4}] Ğ¼Ñ", low, high),
            Language::Russian => format!("Ğ”Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½: [{:.4}, {:.4}] Ğ¼Ñ", low, high),
            Language::Chinese => format!("èŒƒå›´: [{:.4}, {:.4}] æ¯«ç§’", low, high),
        }
    }
    
    /// Format current best value information based on selected language
    pub fn get_current_best(&self, value: f64, score: f64) -> String {
        match self.language {
            Language::English => format!("Current best: {:.4} ms (score={:.4})", value, score),
            Language::Ukrainian => format!("ĞŸĞ¾Ñ‚Ğ¾Ñ‡Ğ½Ğ¸Ğ¹ Ğ½Ğ°Ğ¹ĞºÑ€Ğ°Ñ‰Ğ¸Ğ¹: {:.4} Ğ¼Ñ (Ğ¾Ñ†Ñ–Ğ½ĞºĞ°={:.4})", value, score),
            Language::Russian => format!("Ğ¢ĞµĞºÑƒÑ‰Ğ¸Ğ¹ Ğ»ÑƒÑ‡ÑˆĞ¸Ğ¹: {:.4} Ğ¼Ñ (Ğ¾Ñ†ĞµĞ½ĞºĞ°={:.4})", value, score),
            Language::Chinese => format!("å½“å‰æœ€ä½³: {:.4} æ¯«ç§’ (åˆ†æ•°={:.4})", value, score),
        }
    }
    
    /// Format optimal value recommendation based on selected language
    pub fn get_optimal_value(&self, value: f64) -> String {
        match self.language {
            Language::English => format!("âœ… RECOMMENDED VALUE: {:.4} ms", value),
            Language::Ukrainian => format!("âœ… Ğ Ğ•ĞšĞĞœĞ•ĞĞ”ĞĞ’ĞĞĞ• Ğ—ĞĞĞ§Ğ•ĞĞĞ¯: {:.4} Ğ¼Ñ", value),
            Language::Russian => format!("âœ… Ğ Ğ•ĞšĞĞœĞ•ĞĞ”Ğ£Ğ•ĞœĞĞ• Ğ—ĞĞĞ§Ğ•ĞĞ˜Ğ•: {:.4} Ğ¼Ñ", value),
            Language::Chinese => format!("âœ… æ¨èå€¼: {:.4} æ¯«ç§’", value),
        }
    }
    
    /// Format optimal recommendation command based on selected language
    pub fn get_optimal_recommendation(&self, resolution: i32) -> String {
        match self.language {
            Language::English => format!("SetTimerResolution.exe --resolution {} --no-console", resolution),
            Language::Ukrainian => format!("SetTimerResolution.exe --resolution {} --no-console", resolution),
            Language::Russian => format!("SetTimerResolution.exe --resolution {} --no-console", resolution),
            Language::Chinese => format!("SetTimerResolution.exe --resolution {} --no-console", resolution),
        }
    }
    
    /// Format rank information based on selected language
    pub fn get_rank(&self, rank: usize) -> String {
        match self.language {
            Language::English => format!("Rank {}", rank),
            Language::Ukrainian => format!("Ğ ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³ {}", rank),
            Language::Russian => format!("Ğ ĞµĞ¹Ñ‚Ğ¸Ğ½Ğ³ {}", rank),
            Language::Chinese => format!("æ’å {}", rank),
        }
    }
    
    /// Format iterations with kappa information based on selected language
    pub fn get_iterations_with_kappa(&self, iteration: usize, value: f64, kappa: f64) -> String {
        match self.language {
            Language::English => format!("ğŸ¯ Iteration {}: {:.4} ms (kappa={:.2})", iteration, value, kappa),
            Language::Ukrainian => format!("ğŸ¯ Ğ†Ñ‚ĞµÑ€Ğ°Ñ†Ñ–Ñ {}: {:.4} Ğ¼Ñ (kappa={:.2})", iteration, value, kappa),
            Language::Russian => format!("ğŸ¯ Ğ˜Ñ‚ĞµÑ€Ğ°Ñ†Ğ¸Ñ {}: {:.4} Ğ¼Ñ (kappa={:.2})", iteration, value, kappa),
            Language::Chinese => format!("ğŸ¯ è¿­ä»£ {}: {:.4} æ¯«ç§’ (kappa={:.2})", iteration, value, kappa),
        }
    }
    
    /// Format phase 1 information based on selected language
    pub fn get_phase1(&self, count: usize) -> String {
        match self.language {
            Language::English => format!("ğŸ”¬ Phase 1: Initialization ({} points)", count),
            Language::Ukrainian => format!("ğŸ”¬ Ğ¤Ğ°Ğ·Ğ° 1: Ğ†Ğ½Ñ–Ñ†Ñ–Ğ°Ğ»Ñ–Ğ·Ğ°Ñ†Ñ–Ñ ({} Ñ‚Ğ¾Ñ‡ĞºĞ¸)", count),
            Language::Russian => format!("ğŸ”¬ Ğ¤Ğ°Ğ·Ğ° 1: Ğ˜Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ ({} Ñ‚Ğ¾Ñ‡ĞºĞ¸)", count),
            Language::Chinese => format!("ğŸ”¬ é˜¶æ®µ 1: åˆå§‹åŒ– ({} ç‚¹)", count),
        }
    }
    
    /// Format point information based on selected language
    pub fn get_point_info(&self, current: usize, total: usize, resolution: f64) -> String {
        match self.language {
            Language::English => format!("  ğŸ“ {}/{}: {:.4} ms", current, total, resolution),
            Language::Ukrainian => format!("  ğŸ“ {}/{}: {:.4} Ğ¼Ñ", current, total, resolution),
            Language::Russian => format!("  ğŸ“ {}/{}: {:.4} ms", current, total, resolution),
            Language::Chinese => format!("  ğŸ“ {}/{}: {:.4} æ¯«ç§’", current, total, resolution),
        }
    }
    
    /// Format measurement information with runs and samples based on selected language
    pub fn get_measurement_with_runs(&self, resolution: f64, runs: usize, samples: i32) -> String {
        match self.language {
            Language::English => format!("    ğŸ”¬ Measurement {:.4} ms ({} runs Ã— {} samples)...", resolution, runs, samples),
            Language::Ukrainian => format!("    ğŸ”¬ Ğ’Ğ¸Ğ¼Ñ–Ñ€ÑĞ²Ğ°Ğ½Ğ½Ñ {:.4} Ğ¼Ñ ({} Ğ·Ğ°Ğ¿ÑƒÑĞºÑ–Ğ² Ã— {} Ğ²Ğ¸Ğ±Ñ–Ñ€Ğ¾Ğº)...", resolution, runs, samples),
            Language::Russian => format!("    ğŸ”¬ Ğ˜Ğ·Ğ¼ĞµÑ€ĞµĞ½Ğ¸Ğµ {:.4} ms ({} Ğ¿Ñ€Ğ¾Ğ³Ğ¾Ğ½Ğ¾Ğ² Ã— {} Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ¾Ğº)...", resolution, runs, samples),
            Language::Chinese => format!("    ğŸ”¬ æµ‹é‡ {:.4} æ¯«ç§’ ({} æ¬¡è¿è¡Œ Ã— {} æ ·æœ¬)...", resolution, runs, samples),
        }
    }
    
    /// Format measurement statistics based on selected language
    pub fn get_measurement_stats(&self, mean: f64, p95: f64, mad: f64, outliers: usize) -> String {
        match self.language {
            Language::English => format!("       Î¼={:.4} ms, p95={:.4} ms, MAD={:.4} ms, outliers={}", mean, p95, mad, outliers),
            Language::Ukrainian => format!("       Î¼={:.4} Ğ¼Ñ, p95={:.4} Ğ¼Ñ, MAD={:.4} Ğ¼Ñ, Ğ²Ğ¸ĞºĞ¸Ğ´Ñ–Ğ²={}", mean, p95, mad, outliers),
            Language::Russian => format!("       Î¼={:.4} ms, p95={:.4} ms, MAD={:.4} ms, Ğ²Ñ‹Ğ±Ñ€Ğ¾ÑĞ¾Ğ²={}", mean, p95, mad, outliers),
            Language::Chinese => format!("       Î¼={:.4} æ¯«ç§’, p95={:.4} æ¯«ç§’, MAD={:.4} æ¯«ç§’, å¼‚å¸¸å€¼={}", mean, p95, mad, outliers),
        }
    }
    
    /// Format MeasureSleep.exe error message based on selected language
    pub fn get_measure_sleep_error(&self, error: &str) -> String {
        match self.language {
            Language::English => format!("    âŒ Error running MeasureSleep.exe: {}", error),
            Language::Ukrainian => format!("    âŒ ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ° Ğ·Ğ°Ğ¿ÑƒÑĞºÑƒ MeasureSleep.exe: {}", error),
            Language::Russian => format!("    âŒ ĞÑˆĞ¸Ğ±ĞºĞ° Ğ·Ğ°Ğ¿ÑƒÑĞºĞ° MeasureSleep.exe: {}", error),
            Language::Chinese => format!("    âŒ è¿è¡Œ MeasureSleep.exe é”™è¯¯: {}", error),
        }
    }
    
    /// Format join error message based on selected language
    pub fn get_join_error(&self, error: &str) -> String {
        match self.language {
            Language::English => format!("    âŒ Join error: {}", error),
            Language::Ukrainian => format!("    âŒ ĞŸĞ¾Ğ¼Ğ¸Ğ»ĞºĞ° Ğ¿Ñ€Ğ¸Ñ”Ğ´Ğ½Ğ°Ğ½Ğ½Ñ: {}", error),
            Language::Russian => format!("    âŒ ĞÑˆĞ¸Ğ±ĞºĞ° join: {}", error),
            Language::Chinese => format!("    âŒ Join é”™è¯¯: {}", error),
        }
    }
    
    /// Format timeout error message based on selected language
    pub fn get_timeout_error(&self) -> String {
        match self.language {
            Language::English => "    âŒ MeasureSleep.exe timeout (>30s)".to_string(),
            Language::Ukrainian => "    âŒ Ğ¢Ğ°Ğ¹Ğ¼-Ğ°ÑƒÑ‚ MeasureSleep.exe (>30Ñ)".to_string(),
            Language::Russian => "    âŒ Ğ¢Ğ°Ğ¹Ğ¼Ğ°ÑƒÑ‚ MeasureSleep.exe (>30Ñ)".to_string(),
            Language::Chinese => "    âŒ MeasureSleep.exe è¶…æ—¶ (>30ç§’)".to_string(),
        }
    }
    
    /// Format keep current indicator based on selected language
    pub fn get_keep_current(&self) -> String {
        match self.language {
            Language::English => " (current)".to_string(),
            Language::Ukrainian => " (Ğ¿Ğ¾Ñ‚Ğ¾Ñ‡Ğ½Ğµ)".to_string(),
            Language::Russian => " (Ñ‚ĞµĞºÑƒÑ‰ĞµĞµ)".to_string(),
            Language::Chinese => " (å½“å‰)".to_string(),
        }
    }
    
    /// Format enter new value prompt based on selected language
    pub fn get_enter_new_value(&self) -> String {
        match self.language {
            Language::English => "Enter new value: ".to_string(),
            Language::Ukrainian => "Ğ’Ğ²ĞµĞ´Ñ–Ñ‚ÑŒ Ğ½Ğ¾Ğ²Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ½Ñ: ".to_string(),
            Language::Russian => "Ğ’Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ²Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ: ".to_string(),
            Language::Chinese => "è¾“å…¥æ–°å€¼: ".to_string(),
        }
    }
    
    /// Format exit prompt based on selected language
    pub fn get_exit_prompt(&self) -> String {
        match self.language {
            Language::English => "Press Enter to exit...".to_string(),
            Language::Ukrainian => "ĞĞ°Ñ‚Ğ¸ÑĞ½Ñ–Ñ‚ÑŒ Enter Ğ´Ğ»Ñ Ğ²Ğ¸Ñ…Ğ¾Ğ´Ñƒ...".to_string(),
            Language::Russian => "ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ Enter Ğ´Ğ»Ñ Ğ²Ñ‹Ñ…Ğ¾Ğ´Ğ°...".to_string(),
            Language::Chinese => "æŒ‰ Enter é€€å‡º...".to_string(),
        }
    }
}

/// Language selection function that allows users to choose their preferred language
pub fn select_language() -> Language {
    use std::io::{self, Write};
    use crate::ui::language::Language;
    
    println!("\nğŸŒ Select Language / Ğ’Ğ¸Ğ±ĞµÑ€Ñ–Ñ‚ÑŒ Ğ¼Ğ¾Ğ²Ñƒ / Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ ÑĞ·Ñ‹Ğº / é€‰æ‹©è¯­è¨€");
    println!("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
    
    let languages = Language::all();
    for (i, lang) in languages.iter().enumerate() {
        println!("{}. {}", i + 1, lang.name());
    }
    
    print!("\nSelect language (1-{}): ", languages.len());
    io::stdout().flush().unwrap();
    
    let mut input = String::new();
    io::stdin().read_line(&mut input).unwrap();
    
    let choice = input.trim().parse::<usize>().unwrap_or(1);
    let index = choice.saturating_sub(1).min(languages.len() - 1);
    
    languages[index]
}